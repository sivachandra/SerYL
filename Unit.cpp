#include "Unit.h"

#include "Loader.h"
#include "Support.h"
#include "Type.h"

#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/YAMLParser.h"

#include <cstdlib>

namespace llvm {
namespace ycd {

Unit::Unit(const std::string &InFile, StringRef &PkgName)
    : InputFile(InFile), PackageName(PkgName) {
  Type::addBuiltinTypes(Types);
}

std::unique_ptr<Unit> Unit::load(
    const std::string &Filename,
    const std::vector<std::string> &IncludeDirs) {
  Loader Loader;
  return Loader.load(Filename, IncludeDirs);
}

int Unit::writeCpp(const std::string &Basename) const {
  std::string CppHeader = Basename + ".h";
  std::error_code EC;
  raw_fd_ostream HS(CppHeader, EC);
  if (EC.value() != 0) {
    errs() << "Unable to open " << CppHeader << " for writing.\n";
    return 1;
  }

  HS << "// File generated by SerYL from " << InputFile << ".\n";
  HS << "// Do no edit.\n";

  HS << "\n";

  for (const std::string &Import : ImportedFiles) {
    HS << "#include \"" << StringRef(Import).drop_back(3) << "h\"\n";
  }

  HS << "\n";

  HS << "#include \"llvm/Support/raw_ostream.h\"\n";

  HS << "#include <string>\n";
  HS << "#include <stdint>\n";
  HS << "#include <vector>\n";

  HS << "\n";

  FQNameParts PkgNameParts;
  isFullyQualifiedName(PackageName, PkgNameParts);
  for (const std::string &Part : PkgNameParts) {
    HS << "namespace " << Part << " {\n";
  }

  HS << "\n";  

  for (const Class &Class : Classes) {
    Class.writeCppDefinition(HS);
    HS << "\n";
  }

  HS << "\n";

  for (auto RI = PkgNameParts.rbegin(); RI != PkgNameParts.rend(); ++RI) {
    HS << "} // namespace " << *RI << "\n";
  }

  return 0;
}

} // namespace ycd
} // namespace llvm
